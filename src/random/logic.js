const UTTT = require('@socialgorithm/ultimate-ttt').default;
const ME = require("@socialgorithm/ultimate-ttt/dist/model/constants").ME;
const OPPONENT = require("@socialgorithm/ultimate-ttt/dist/model/constants").OPPONENT;
/**
 * Random implementation - Do not edit this file!
 *
 * This is here so that you can play against it and test your player :)
 */

class GameLogic {
  constructor(player, size = 3){
    if(!player || player < ME || player > OPPONENT){
      throw new Error('Invalid player');
    }

    this.size = size;
    this.player = player;
    this.opponent = 1 - player;

    this.init();
  }

  /* ----- Required methods ----- */

  /*
   * New Game Has Been Started.
   * Do Whatever You Need To Do For The Player To Be Ready To Play
   */
  init(){
    this.game = new UTTT(this.size);
  }

  /**
   * You are the First To Move
   * Place Whereever You Want
   * You Get To Pick The Board
   * 
   * @returns {{board: [number,number], move: [number, number]}} Position coordinates {board: [row, col], cell: [row, col]}
   */
  onMove() {
    try {
      const coords = this.getMove();
      this.addMove(coords.board, coords.move);
      return coords;
    } catch (e) {
        console.error('-------------------------------');
        console.error("\n"+'AddOpponentMove: Game probably already over when adding', board, move, e);
        console.error("\n"+this.game.prettyPrint());
        console.error("\n"+this.game.stateBoard.prettyPrint(true));
        console.error('-------------------------------');
        throw new Error(e);
    }
  }

  /**
   * Opponent Has Moved.
   * You Have Opponents Board
   * You Have Opponents Move
   * 
   * You Must Respond With Board Matching Opponents Move
   * Unless That Board Is Complete
   * 
   * @param board Board identifier [row, col]
   * @param move Cell identifier [row, col]
   * @returns {{board: [number,number], move: [number, number]}} Position coordinates {board: [row, col], cell: [row, col]}
   * 
   */
  onOpponentMove(board, move) {
    try {
        this.game = this.game.addOpponentMove(board, move);
        if (!this.game.isFinished()) {
          const coords = this.getMove();
          this.addMove(coords.board, coords.move);
          return coords;
        }
    } catch (e) {
        console.error('-------------------------------');
        console.error("\n"+'AddOpponentMove: Game probably already over when adding', board, move, e);
        console.error("\n"+this.game.prettyPrint());
        console.error("\n"+this.game.stateBoard.prettyPrint(true));
        console.error('-------------------------------');
        throw new Error(e);
    }
  }

  /**
   * Game Is Over.
   * You May Wish To Change Stratagy For The New Game.
   * Your Opponent Has Not Changed.
   * 
   * @param result Either 'win' | 'lose' | 'tie'
   * @param board Last Opponent Board identifier [row, col]
   * @param move Last Opponent Cell identifier [row, col]
   * @returns {undefined}
   */
  gameOver(result, board, move) {
    if(board && move) {
      this.game.addOpponentMove(board, move);
    }
    if (result === 'win') {
      // console.debug('win');
      /* DO SOMETHING WITH WIN NEWS */
    } else if (result === 'lose') {
      // console.debug('lose');
      /* DO SOMETHING WITH LOSE NEWS */
    } else if (result === 'tie') {
      // console.debug('tie');
      /* DO SOMETHING WITH TIE NEWS */
    }
  }

  /**
   * Match Is Over.
   * You Will Soon Have A New Opponent.
   * 
   * @param result Either 'win' | 'lose' | 'tie'
   * @returns {undefined}
   */
  matchOver(result) {
    if (result === 'win') {
      // console.debug('win');
      /* DO SOMETHING WITH WIN NEWS */
    } else if (result === 'lose') {
      // console.debug('lose');
      /* DO SOMETHING WITH LOSE NEWS */
    } else if (result === 'tie') {
      // console.debug('tie');
      /* DO SOMETHING WITH TIE NEWS */
    }
  }

  
  /**
   * Game Is Over.
   * You Have Timed Out.
   */
  timeout() {
      // console.debug('timeout');
  }


  /* ---- Non required methods ----- */

  addMove(board, move){
    try {
        this.game = this.game.addMyMove(board, move);
    } catch (e) {
        console.error('-------------------------------');
        console.error("\n"+'AddMyMove: Game probably already over when adding', board, move, e);
        console.error("\n"+this.game.prettyPrint());
        console.error("\n"+this.game.stateBoard.prettyPrint(true));
        console.error('-------------------------------');
        throw new Error(e);
    }
  }

  getMove(){
    const boardCoords = this.chooseBoard();
    const board = this.game.board[boardCoords[0]][boardCoords[1]];
    const move = this.findRandomPosition(board);

    return {
        board: boardCoords,
        move: move
    };
  }

  /**
   * Choose a valid board to play in
   * @returns {[number,number]} Board identifier [row, col]
   */
  chooseBoard() {
    let board = this.game.nextBoard || [0, 0];

    if(!this.game.board[board[0]][board[1]].isFinished()){
        return board;
    }

    const validBoards = this.game.getValidBoards();
    if (validBoards.length === 0) {
        // this case should never happen :)
        console.error("\n" + this.game.prettyPrint());
        console.error("\n" + this.game.stateBoard.prettyPrint(true));
        throw new Error('Error: There are no boards available to play');
    }

    return validBoards[
        Math.floor(Math.random() * validBoards.length)
        ];
  }

  /**
   * Get a random position to play in a board
   * @param board Board identifier [row, col]
   * @returns {[number,number]} Position coordinates [row, col]
   */
  findRandomPosition(board) {
      if (board.isFull() || board.isFinished()) {
        console.error('This board is full/finished', board);
        console.error(board.prettyPrint());
        return;
      }
      const validMoves = board.getValidMoves();
      if (validMoves.length === 0) {
        // this case should never happen :)
        throw new Error('Error: There are no moves available on this board');
      }

      return validMoves[
        Math.floor(Math.random() * validMoves.length)
      ];
  }
}

module.exports = GameLogic;