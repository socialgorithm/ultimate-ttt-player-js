import {GameResult, IPlayer} from "../../types";
import {Coord, Coords, PlayerNumber} from "@socialgorithm/ultimate-ttt/dist/model/constants";
import {AbstractPlayer} from "../AbstractPlayer";
import UTTT from "@socialgorithm/ultimate-ttt";
import SubBoard from "@socialgorithm/ultimate-ttt/dist/SubBoard";

/**
 * Random implementation - Do not edit this file!
 *
 * This is here so that you can play against it and test your player :)
 */

export class RandomPlayer extends AbstractPlayer {

    constructor(player: PlayerNumber, size: number) {
        super(player, size);
    }

    init(): void {
        this.game = new UTTT(this.size);
    }

    addOpponentMove(coords: Coords): void {
        try {
            this.game = this.game.addOpponentMove(coords.board, coords.move);
        } catch (e) {
            console.error('-------------------------------');
            console.error("\n" + 'AddOpponentMove: Game probably already over when adding', coords.board, coords.move, e);
            console.error("\n" + this.game.prettyPrint());
            console.error("\n" + this.game.stateBoard.prettyPrint(true));
            console.error('-------------------------------');
            throw new Error(e);
        }
    }

    addMove(coords: Coords): void {
        try {
            this.game = this.game.addMyMove(coords.board, coords.move);
        } catch (e) {
            console.error('-------------------------------');
            console.error("\n" + 'AddMyMove: Game probably already over when adding', coords.board, coords.move, e);
            console.error("\n" + this.game.prettyPrint());
            console.error("\n" + this.game.stateBoard.prettyPrint(true));
            console.error('-------------------------------');
            throw new Error(e);
        }
    }

    getMove(): Coords {
        const boardCoords = this.chooseBoard();
        const board : SubBoard = this.game.board[boardCoords[0]][boardCoords[1]];
        const move = this.findRandomPosition(board);

        return {
            board: boardCoords,
            move: move
        };
    }

    timeout(): void {
        // YOU HAVE TIMED OUT
        // YOU MAY WANT TO RESPOND
    }

    gameOver(result: GameResult, move?: Coords): void {
        // GAME IS OVER, OPPONENT WONT CHANGE
    }

    matchOver(result: GameResult, move?: Coords): void {
        // MATCH IS OVER, OPPONENT MAY CHANGE
    }

    /* ---- Non required methods ----- */

    /**
     * Choose a valid board to play in
     * @returns {[number,number]} Board identifier [row, col]
     */
    chooseBoard() : Coord {
        let board: Coord = this.game.nextBoard || [0, 0];

        if (!this.game.board[board[0]][board[1]].isFinished()) {
            return board;
        }

        const validBoards: Coord[] = this.game.getValidBoards();
        if (validBoards.length === 0) {
            // this case should never happen :)
            console.error("\n" + this.game.prettyPrint());
            console.error("\n" + this.game.stateBoard.prettyPrint(true));
            throw new Error('Error: There are no boards available to play');
        }

        return validBoards[
                Math.floor(Math.random() * validBoards.length)
            ];
    }

    /**
     * Get a random position to play in a board
     * @param board Board identifier [row, col]
     * @returns {[number,number]} Position coordinates [row, col]
     */
    findRandomPosition(board : SubBoard) : Coord  {
        if (board.isFull() || board.isFinished()) {
            console.error('This board is full/finished', board);
            console.error(board.prettyPrint());
            throw new Error('Error: This board is finished');
        }
        const validMoves = board.getValidMoves();
        if (validMoves.length === 0) {
            // this case should never happen :)
            throw new Error('Error: There are no moves available on this board');
        }

        return validMoves[
            Math.floor(Math.random() * validMoves.length)
            ];
    }
}